virtual box image
4 services running
each service has multiple vulnabilities
need to assign the IP of my team

レジスタとスタック
プロセッサのアーキテクチャによってどのような命令が用意されているかが変わってくる

現在、汎用コンピュータにおいて最もよく用いられているプロセッサアーキテクチャであるx86アーキテクチャ

レジスタ
プロセッサ内に存在する記憶装置であり、メモリや補助記憶装置と比較して、高速に動作する
そのため、プロセッサが命令を実行する際には、直接メモリを操作するのではなく、メモリからレジスタに読み出したデータに対して操作することが多くなっている

記憶容量自体は32bitや64bit程度のものが多い

プロセッサについて、一般に32bit CPU, 64bit CPUなどと故障することがあるけど、これはレジスタ幅によって決められている

プロセッサは大抵複数のレジスタを持ち、用途によって使い分けている

x86アーキテクチャの持つレジスタ
EAX, ECX, EDX, EBX, ESI, EDIの６つの汎用レジスタ、EBP, ESP, EIPの特殊レジスタ、フラグレジスタのEFLAGSレジスタ、セグメントレジスタがある

ESI, EDIの２つのレジスタはまとめてインデックスレジスタと呼ばれる場合もある

いずれのレジスタも32biのレジスタ長をもつ

汎用レジスタのうち、EAX, ECX, EDX, EBXのレジスタの下位16bitは、それぞれAX, CX, DX, BXレジスタと呼ばれ、さらに、そのうち上位8bitはAH, CH, DH, BHレジスタ(HはHighのH)、下位8bitはAL, CL, DL, BLレジスタ(LはLowのL)と呼ばれる

ESI, EDIレジスタの下位16bitは、それぞれSI, DIレジスタと呼ばれる


汎用レジスタは、基本的にどんな使い方をしても問題ない

しかし、それぞれのレジスタには通例としての使い道があり、各々がその使い道を示す名前を持ち、それぞれにあった使い方をされる場合が多い

・EAX(アキュームレータレジスタ)　演算の結果を格納する
・ECX(カウンタレジスタ)　ループの回数などのカウントを格納する
・EDX(データレジスタ)　演算に用いるデータを格納する
・EBX(ベースレジスタ)　アドレスのベース値を格納する
・ESI(ソースインデックスレジスタ)　一部のデータ転送命令において、データの転送元を格納する
・EDI(デスティネーションインデックスレジスタ)　一部のデータ転送命令において、データの転送先を格納する

厳密に規定はされていない、これらと異なる使いかたをされることもある

特殊レジスタ(ポインタレジスタ)には、それぞれ専用の用途がある

・EBP(ベースポインタレジスタ)　現在のスタックフレームにおける底のアドレスを保持(関数の引数を表すときに使うレジスタ)
・ESP(スタックポインタレジスタ)　現在のスタックトップのアドレスを保持
・EIP(インストラクションポインタレジスタ)　次に実行するアセンブリ命令のアドレスを保持

これらについては、ベースポインタ、スタックポインタ、命令ポインタと呼称することがある

フラグレジスタは、おもに前の命令による操作の結果として、生じたある状態やプロセッサの状態を格納する

このレジスタの保持している値によって、動作の変わる命令などがあり、操作の内容を決定する要素となっている

EFLAGSレジスタと呼ばれる１個の32bitレジスタで実装されていて、その中に１７個のフラグが格納される(32bitの全てが使われているわけではない)

以下は、バイナリ解析の際に、比較的利用する頻度があるフラグ

これらはZFを中心に、おもに文字列処理命令や条件分岐命令などで用いられる

・CF(キャリーフラグ)　演算命令でキャリー(桁上がり)かボロー(桁借り)が発生した時にセットされる
・ZF(ゼロフラグ)　操作の結果が０になった場合にセットされる
・SF(符号フラグ)　操作の結果が負となった場合にセットされる
・DF(方向フラグ)　ストリームの方向を制御する
・OF(オーバーフローフラグ)　符号つき算術演算の結果がレジスタの格納可能範囲を超えた場合にセットされる

セグメントレジスタはセグメントのアドレスを参照するのに用いられるレジスタ
セグメントとは、メモリを管理するために、格納するデータの種類によって領域として区切ったもので、セグメントをメモリ管理に用いる方式をセグメント方式と言う

アドレスは１６バイトを１単位とするセグメント値と、その位置からのずれであるオフセット値という２つの値から成り立っている。

普通Ｃ言語で扱うアドレスとは、このオフセット値のほう。

セグメントを用いるそれぞれのレジスタが、対応するセグメントの先頭のアドレスを保持する

（ＣＴＦで配布されるバイナリで、セグメントレジスタを用いた命令を見る機会はあまり多くない）

各レジスタ、省略


ＣＰＵはレジスタと、メモリと、即値(定数)を主に操作できる
だけど、メモリ同士の演算はできず、片方の値を一旦レジスタに入れて、その後に演算を行う必要がある

だから、Ｃ言語のa = bという文はアセンブラでは２文になる

レジスタに余裕がなく、レジスタの値を一旦メモリ(スタック)に保持する必要があれば、さらに命令数は増える

アセンブラの命令はニーモニック(mnemonic:(形)記憶を助ける)と呼ばれる

ニーモニックは普通オペランドを取る。オペランドとは引数のようなもの

メモリは、アドレスを使って操作する。静的な変数は即値を、動的な変数は普通はEBPレジスタを利用してアクセスする。

汎用レジスタ、特殊レジスタ(ポインタレジスタ)にアドレスを入れると、dword ptr [eax]のようにして参照できる。

dwordというのは4バイトのこと。

例えば、変数aのアドレスがEAXレジスタに入っているとすると、mov dword ptr [eax], 1000とすると、aに1000を代入できる

サイズを書かなくてもサイズが勝手に決まってしまうときは、サイズを省略することができる

アドレスの指定はもっと複雑にできる

dword ptr [eax + ebx * 4 + 8]なんてこともできる

レジスタ1個、1, 2, 4, 8倍指定のついたレジスタが1個、即値が1個の和を指定することができる

１次元配列を扱うことができるというわけ

アドレスを取得するニーモニック lea を使えば、この条件にあう演算を1命令でできたりするというテクニックもある

関数について

Ｃ言語の関数は、普通、引数はスタックに渡す。（インライン関数やファストコール関数は例外）内部変数もスタックに確保される

戻り値は普通 EAXレジスタに入れる


ポインタは変数のままでは扱えない。アドレス先を参照するには、ポインタの中身を一旦レジスタに渡す必要がある。それは、メモリにある値を使って参照ができないから。

loop というニーモニックを使うと、ECXレジスタに入っている数だけループすることができる。一回ループをするたびにECXレジスタの値を１ずつマイナスしていき、０になったらループをやめるというふうになっている

ただ、データ数に０以下の値を入れられるとまずいので、その際には０を返すようにする。

xor eax, eax というのは、レジスタを０にクリアする方法の一つ。

mov eax, 0 でもできるけど、こっちのほうがマシン語に直すとサイズが小さくなる。

cmp ecx, 0 これはECXと０を比較するという文。比較した結果はフラグレジスタにセットする。

jle END_FUNC という文は前回の比較の結果が、Less than or Equal(以下)であったとき分岐を行うという文。

前回の比較は ECX と ０との比較。よって、ECX≦０の時に関数の最後に飛ぶ、という文になる。

j は Jump の j で、le はもちろん、Less than or Equalの略

add eax, [ebx]で、データを足す。add ebx, 4でアドレスを次の要素に進める。

int は４バイトなので、４を足す。

そして、loop LOOP_HEADでループを行う。

除算は EDX, EAX 両レジスタにまたがって被除数を入れておく必要がある。だけど、データは EAXレジスタにしか入ってない。

これを EDX:EAXに拡張するニーモニックが cdq 。

で、除算をidiv nData で行う。

idiv は符号付き除算を行うニーモニック。結果は、商が EAX に、余りが EDX に格納される。

アセンブラでは商と余りを同時に出してくれる。その代わり４００億割る１とかしたら EAX に４００億なんて入らないからオーバーフロー（桁あふれ）になる。これは除算エラー例外を発生する。


関数を呼ぶニーモニックは call。関数内の ret というニーモニックに当たるとここに戻ってくる

引数はスタックに渡す。スタックに値を渡すニーモニックは push

関数が終わると、スタックの位置をプッシュする前の位置に戻す必要がある

プッシュすると、ESPが小さくなる。だから、ESPにプッシュしたサイズを足すと、スタックの位置を戻すことができる

スタックからプッシュした数だけ値を取り出したのでも位置を戻すことができる

スタックから値を取り出すニーモニックは pop

また、変数のアドレスは offset という演算子を使うと取得できる

ただし、それは静的な変数のみ。動的な変数に対しては lea というニーモニックを用いて取得する

[基本的なアセンブラ命令]
代入：mov, movzx, movsx, lea, xchg, movs/rep/cld/std, stos, lods (, cmovcc)
演算：add/adc, sub/sbb, mul, imul, div, idiv/cdq, neg (, lea)
1の加減算：inc, dec
ヒット演算：and, or, xor, not
ヒットシフト：shl/sar/shr, rcl/rol/ror
ヒット操作：bts, btc, btr
比較：cmp, test, bt, bsf, bsr, cmps, scas
スタック操作：push, pop, pusha, popa, pushf, popf
分岐：jmp, jcc, call/ret
フラグの取得：setcc

push 現在のスタック位置(esp)がマイナスされ、その位置にデータが書き込まれる。

pop その位置のデータが読み込まれ、スタック位置は増える

push は先に esp の値を変えてからそのアドレスの位置に値を設定
pop　は先に値を取り出してから、espの値を変更する

call の実際の処理
呼び出し元のアドレス（正しくは、ret命令の後に戻るべきアドレス）をスタックにキープしてから、指定したアドレスまたはレジスタの値が指すアドレスに処理を移す。

すると、espの値がさすアドレスには関数を終えたときに戻るべきアドレスが入っているため、dword ptr [esp]とすることでそのアドレスを取得することができる

ret命令
現在のスタックからアドレスを取得して実行位置をそれに設定し、espを加算する

espの値は直接書き換えることができる
espの値を直接変更する手順は、通常スタック上に一時的にデータをキープしたいときに、そのデータが書き換わらないように行う

sub で esp の値のみを変更して、add で戻す、など
