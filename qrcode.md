seccon 2013 for400 qrコードはデータコード語が丸々残っている＆モードは英数字モードのみ

seccon 2014 for200 qrコードはデータコード語が丸々残っている＆モードは英数字モードと8bitモードが混在している

seccon 2014 for400 qrコードはエラー訂正コード語のみが残っている


QRコードの仕様
------------------------------------------------------------

先頭4bitがモード指示子、次の9bit(英数字が前提において）が文字数指示子
残りが実データ
だが、実際に配置されたデータコード語を読む際は
実データの部分を11bit区切りで読む

QRコード作成時は、モード指示子、文字数指示子、実データ部分を含めたbit列を
8bit区切りで１０進化して、それを元にエラー訂正コード語（誤り訂正コード語）を求めている

よって、誤り訂正コード語を求めるのであれば、全てのbit列を
モード指示子、文字数指示子、実データ部分(11bit区切り)で読むのではなく、8bit区切りで読んで得られたbit列を
それぞれ１０進化したものから、誤り訂正コード語を求めるのが望ましい

エラー訂正コード語数はインターリーブ配置されていない状態から求めたもの


QRコード準備
------------------------------------------------------------

[データ容量]

１つのＱＲコードが格納できるデータ数はデータの種類（数字・英数字など） バージョン　誤り訂正レベルによって決定される

http://www.swetake.com/qrcode/qr_table0.html

表の通り

同一データ数で誤り訂正レベルを高くすればシンボルのバージョンが上がり、シンボルの大きさが大きなる

TODO:シンボルの誤り訂正レベル、また必要であればバージョンも決めておく


[データコード語の作成]
------------------------------------------------------------

ＱＲコードでは8bitを１コード語として扱い、誤り訂正語計算やデータの配置など、すべて8bitで行う

じゃあ、どうやって8bti単位のコード語に変換するの？


1.モード指示子
------------------------------------------------------------

まず最初にモードを4bitで表示

数字モードならば　0001
英数字モードならば　0010
8bitバイトならば　0100
漢字ならば　1000


2.文字数指示子
------------------------------------------------------------

格納する文字数を下記のbit数で表記する（下記はバージョン１～９の場合）

数字モードならば　10bit
英数字モードならば　9bit
8bitバイトならば　8bit
漢字ならば　8bit


3.データの２進化
------------------------------------------------------------

実データを２進化する
数字モードではデータを３桁ずつ区切ってそのまま整数として読んだものをデータとする

すなわち"123456"とあれば"123"と"456"に分割し１つめのデータを"123"、２つめを"456"とする

そしてそれぞれを10bitの２進数で表す
もし３桁に満たない場合はそれぞれ4bit,7bitの２進数で表す

例えば"9876"とあれば"987"と"6"に分けて10bitで987、4bitで6を表現する
よってこの場合は　1111011011 0110 となる

英数字モードではまず、表２（http://www.swetake.com/qrcode/qr_table1.html ）の通りに各文字を数字化する

データを２桁づつ区切って１桁めの文字の上記の表の値を４５倍したものと、２桁目の文字の上記の表の値を足す
算出された値を11bitの２進数で表記する なお２桁に満たない場合は残った場合は対応する値を6bitで表記する

なお8bitデータの場合はその数字をそのまま8bit単位で割り振る


4.終端パターン
------------------------------------------------------------

最後に終端パターンとして0000を付加する

ただし、データビット列がシンボル容量を満たしている場合は必要ない


5.コード語変換
------------------------------------------------------------

QRcode model2ではデータはすべて8bitの単位で処理するので上記のデータを8bit毎に区切る

最後のビット列が8bit未満の場合は0で埋める

得られたコード数がシンボルのデータコード語数（http://www.swetake.com/qrcode/qr_table0.html ）に満たない場合は11101100 および 00010001を交互に付加してシンボル容量に合わせる（8bitが１コード）

得られたbit列を１０進化しておわり


[誤り訂正コード語の作成]
------------------------------------------------------------

得られた１０進数の列を自作スクリプトに投げておしまい


[seccon 2013 for400]
------------------------------------------------------------
与えられた写真を見る

マスクかかっているからそのままじゃ読めない

マスクを解除しよう、でもマスクパターンは？

BCH符号を用いて求められた誤り訂正ビットは残っていないか？

右上のマーカーの下の部分から、誤り訂正ビットの下位8bitなら読み取れる

全パターンから計算

結果、モードやマスクパターンなどの形式情報が求まる

じゃあ、マスクを解除（今回は市松模様）すればデータコード語は読み取れる

あとは、右下からインターリーブ配置されていることに注意しながら読んでいく

そうして求められたビット列は、先頭の4bitはモード指示子（今回は英数字モード）

英数字モードなので、次の9bitが文字数指示子で、その後のビット列を11bit区切りで読んでいけば実データ部分が読み取れる


[完全復元について]
-------------------------------------------------------------

まず、先ほど読んでいったデータコード語のビット列（２進数の）を8bit区切りで１０進数化する

そうして求めたものから、エラー訂正コード語を求めることができる

１０進数化したものを係数として、得られる多項式と、エラー訂正コード語数と総コード語数から決まるg(x)のパターンを除算してどうこう・・・・

ここは実際にやっていくと時間が足りないので、用意した自作スクリプトに投げる

そうして出てきた１０進数の列、また２進数のビット列が、求まったエラー訂正コード語

よって、マスクを解除したQRコード（右側しかないやつ）をデータコード語が終わっている部分から埋めていく

edge2というドット絵を描くためのツールを使って、QRコードを書いていく

（ここで１ドットずつ打っていくと時間が足りないようだったら、マスクパターンも用意しておく）

ようやく完成したように見えるが、実はこれではまだQRコードリーダーなどでは読み取れない

マスクをかける必要があるので（今回は市松模様）、マーカー部分や始めから決まっている部分を除いた場所に市松模様にマスクをかけていく

今回はそのマスクパターンを用意したので、「選択範囲をファイルから読み込む」で読み込んで → イメージ → 色置換→ １色、１色 一括変換 → 白黒反転するように指定

こうしてようやく完成！
